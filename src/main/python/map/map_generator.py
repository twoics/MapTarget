from src.main.python.tree.tree import KdTree
from src.main.python.map.queries import query_by_reserved, query_by_name, get_reserved
from src.main.python.map.map_initializer import pure_custom_map
from itertools import zip_longest
from typing import Union, Tuple
import folium
import overpy

POINT = [Union[float, int], Union[float, int]]
MAP_POINT = Tuple[Union[float, int], Union[float, int], dict]

STANDARD_ICON = 'info-circle'
ICONS = {
    'cafe': 'coffee',
    'fast_food': 'cutlery',
    'restaurant': 'cutlery',
    'bar': 'beer',
    'cinema': 'film',
    'fitness': 'hand-rock-o',
    'museum': 'university',
    'library': 'book',
    'supermarket': 'shopping-basket',
    'clothes': 'shopping-bag',
    'mall': 'building',
    'electronic': 'calculator',
    'hospital': 'hospital-o',
    'fuel': 'tint',
    'hotel': 'bed',
    'pharmacy': 'plus-square',
}


class Map:
    def __init__(self):
        self._map = None
        self._points_obj = None
        self._tree = KdTree()
        self._user_input = None
        self._current_zoom = None

    def set_zoom(self, zoom: int):
        self._current_zoom = zoom

    def pure_map(self) -> folium.Map:
        """
        Generate new Pure Map
        :return: Folium Map
        """
        self._map = pure_custom_map()
        self._points_obj = None
        return self._map

    def map_by_name(self, name: str, start_point: POINT, end_point: POINT) -> folium.Map:
        """
        Build new folium map based on a query by name
        :param name: The name of the objects to be found
        :param start_point: Starting point of the search
        :param end_point: Ending point of the search
        :return: folium map generated by name
        """
        query_res = query_by_name(name, start_point, end_point)
        self._user_input = name

        return self._build_map_by_query(query_res, start_point, end_point)

    def map_by_reserved(self, reserved_type: str, start_point: POINT, end_point: POINT) -> folium.Map:
        """
        Based on a request for a specific type of object
        :param reserved_type: Reserved object type
        :param start_point: Starting point of the search
        :param end_point: Ending point of the search
        :return: folium map generated by reserved type
        """
        query_res = query_by_reserved(reserved_type, start_point, end_point)
        self._user_input = reserved_type

        return self._build_map_by_query(query_res, start_point, end_point)

    def find_closest(self, pivot: POINT) -> Union[folium.Map, None]:
        """
        Searches the current map for the nearest
        object to the point, then marks the nearest
        object to it, and returns a modified map
        :param pivot: The point for which the nearest object is searched for
        :return: Modified map
        """
        if not self._points_obj:
            return None

        self._tree.rebuild_tree(tuple(self._points_obj))
        closest = self._tree.closest_node_map(pivot[0], pivot[1])
        closest_point = (closest.point.x, closest.point.y)

        # It is necessary to rebuild, because I can not replace the color at the marker,
        # Can say that I copy the old map, but replace the color at the nearest point
        self._rebuild_by_target(trigger_point=closest_point)

        # Here I add a user point to the map
        folium.Marker(
            [pivot[0], pivot[1]],
            icon=folium.Icon(
                icon=STANDARD_ICON,
                prefix="fa",
                color='red'),
            popup=f"<i>{'PIVOT'}</i>"
        ).add_to(self._map)

        return self._map

    def get_reserved_queries(self) -> list:
        return get_reserved()

    def _build_map_by_query(self, query: overpy.Result, start_point: POINT, end_point: POINT) -> folium.Map:
        """
        Builds a map, based on the result of the overpy.Result query
        :param query: Query result of overpy
        :return: New generated map
        """
        self._points_obj = _get_points(query)

        location = [(end_point[0] + start_point[0]) / 2, (end_point[1] + start_point[1]) / 2]

        self._map = pure_custom_map(location=location, zoom=self._current_zoom)

        for point_obj in self._points_obj:
            point_data = _get_html_point_info(point_obj[2])

            folium.Marker(
                [point_obj[0], point_obj[1]],  # Set cords
                icon=folium.Icon(
                    icon=ICONS.get(self._user_input, STANDARD_ICON),
                    prefix="fa"),
                popup=folium.Popup(folium.IFrame(point_data),
                                   min_width=150,
                                   max_width=200)
            ).add_to(self._map)
        return self._map

    def _rebuild_by_target(self, trigger_point: POINT) -> folium.Map:
        """
        Builds a map based on the previous one, i.e. using its self._points_obj,
        and when it finds a trigger point, marks it in a special way.

        DOESN'T CHANGE self._points_obj
        :param trigger_point: The point to be marked in a special way
        :return: New generated map
        """
        self._map = pure_custom_map(location=trigger_point, zoom=self._current_zoom)

        for point_obj in self._points_obj:
            point_data = _get_html_point_info(point_obj[2])

            folium.Marker(
                [point_obj[0], point_obj[1]],  # Set cords
                icon=folium.Icon(
                    icon=ICONS.get(self._user_input, STANDARD_ICON),
                    color='green' if _compare(trigger_point, point_obj) else 'blue',
                    prefix="fa"),
                popup=folium.Popup(folium.IFrame(point_data),
                                   min_width=150,
                                   max_width=200)
            ).add_to(self._map)
        return self._map


def _get_points(answer_query: overpy.Result) -> list:
    """
    Returns a list of points that show the location
    of an object on the map, by type of query
    :param answer_query: Query Result from overpy
    :return: List With points and data: [(latitude_1, longitude_1, {data_1}), (latitude_2, longitude_2, {data_2})]
    """
    points_list = []
    for node, way, rel in zip_longest(answer_query.nodes, answer_query.ways, answer_query.relations):
        if rel:
            points_list.append((float(rel.center_lat), float(rel.center_lon), rel.tags))
        if way:
            points_list.append((float(way.center_lat), float(way.center_lon), way.tags))
        if node:
            points_list.append((float(node.lat), float(node.lon), node.tags))
    return points_list


def _compare(point_1: POINT, point_2: POINT):
    """
    Compare two points
    :return: Are points equal
    """
    return point_1[0] == point_2[0] and point_1[1] == point_2[1]


def _get_html_point_info(point_data: dict) -> str:
    """
    Return HTML for Marker PopUP
    :param point_data: Tags that contain a point
    :return: HTML as string
    """
    return f"""Name: {point_data.get('name', 'n/a')}<br>Amenity: {point_data.get('amenity', 'n/a')}"""
